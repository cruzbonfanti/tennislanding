<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Tennis Ball Layers Test</title>
<style>
  html, body { margin: 0; overflow: hidden; background: #000; }
  #c {
    position: absolute;
    top: 0;
    left: 0;
    display: block;
    z-index: 0;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

// --- CANVAS Y ESCENA ---
let sceneWidth = 1920;   // tama√±o total de la escena virtual
let sceneHeight = 720;
const sceneCanvas = document.createElement("canvas");
sceneCanvas.width = sceneWidth;
sceneCanvas.height = sceneHeight;
const sctx = sceneCanvas.getContext("2d");

// C√°mara virtual (porci√≥n visible)
let cameraWidth = window.innerWidth;
let cameraHeight = window.innerHeight;
let cameraX = 0;
let cameraY = 0;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  cameraWidth = canvas.width;
  cameraHeight = canvas.height;
}
resize();
window.addEventListener("resize", resize);

// --- IMAGENES ---
const bgImg = new Image();
bgImg.src = "./tenniscourt.jpg";
const shadowOverlayImg = new Image();
shadowOverlayImg.src = "./tenniscourt_shadows.png";
const highlightImg = new Image();
highlightImg.src = "./highlight.png";
let highlightReady = false;
highlightImg.onload = () => highlightReady = true;

// ---------------- CONFIG ----------------
const BALL_COUNT = 350;
const BALL_SCALE = 1.1;
const BALL_FRAME_COUNT = 48;
const BALL_FRAME_EXT = ".png";
const BALL_ANIM_SETS = ["./Ball_animation1/", "./Ball_animation2/", "./Ball_animation3/"];
const BALL_SPIN_SPEED = 0.22;
const SPIN_FREEZE_SPEED = 0.08;
const TRACKS_SPEED_THRESHOLD = 0.10;
const TRACKS_WIDTH = Math.max(6, 12.0 * BALL_SCALE);
const TRACKS_ALPHA = 0.035;
const TRACKS_COLOR = "0,0,0";
const TRACKS_MIN_SEGMENT = Math.max(0.6, 1.2 * BALL_SCALE);
const ROT_OFFSET = 0;
const HEADING_SMOOTH = 0.15;
const BALL_RADIUS_BASE = 22;
const BALL_RADIUS = BALL_RADIUS_BASE * BALL_SCALE;
const BALL_DIAMETER = BALL_RADIUS * 2;
const DEPTH_MIN = 0.97;
const DEPTH_MAX = 1.03;
const REPULSION_RADIUS_BASE = 110;
const REPULSION_FORCE = 5.5;
const REPULSION_RADIUS = REPULSION_RADIUS_BASE * BALL_SCALE;
const MOUSE_MOVE_THRESHOLD_PX = 1;
const MOUSE_REPULSE_COOLDOWN_FRAMES = 70;
const FRICTION = 0.75;
const SLEEP_VEL = 0.1;
const SHADOW_OPACITY = 0.7;
const SHADOW_STRETCH_X = 1.5;
const SHADOW_STRETCH_Y = 0.5;
const SHADOW_OFFSET_X = 14 * BALL_SCALE;
const SHADOW_OFFSET_Y = 16 * BALL_SCALE;
const HIGHLIGHT_OPACITY = 0.7;
const HIGHLIGHT_SIZE = 44 * BALL_SCALE;
const HIGHLIGHT_OFFSET_X = 0;
const HIGHLIGHT_OFFSET_Y = 0;
const PARALLAX_MAX_PX = 15;
const PARALLAX_SMOOTH = 0.08;
const SHADOW_PARALLAX_MULT = 0.4;
const SHADOW_PARALLAX_SMOOTH = 1;
const SHADOWOVERLAYO_PACITY = 0.7;

// canvas huellas
sctx.lineCap = "round";
sctx.lineJoin = "round";
sctx.lineWidth = TRACKS_WIDTH;

// mouse + parallax
const mouse = { x: -9999, y: -9999, px: -9999, py: -9999 };
let parallaxX = 0, parallaxY = 0;
let parallaxTargetX = 0, parallaxTargetY = 0;
let shadowPX = 0, shadowPY = 0;
let mouseRepulseFramesLeft = 0;

window.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
  const nx = (mouse.x / cameraWidth) * 2 - 1;
  const ny = (mouse.y / cameraHeight) * 2 - 1;
  parallaxTargetX = -nx * PARALLAX_MAX_PX;
  parallaxTargetY = -ny * PARALLAX_MAX_PX;
  const dx = mouse.x - mouse.px;
  const dy = mouse.y - mouse.py;
  if (mouse.px < -9000) { mouse.px = mouse.x; mouse.py = mouse.y; return; }
  if (Math.sqrt(dx*dx+dy*dy) >= MOUSE_MOVE_THRESHOLD_PX) mouseRepulseFramesLeft = MOUSE_REPULSE_COOLDOWN_FRAMES;
  mouse.px = mouse.x; mouse.py = mouse.y;
});

// ================== LOAD FRAMES ==================
const setsFramesCompact = BALL_ANIM_SETS.map(() => []);
const setsEffectiveCount = new Array(BALL_ANIM_SETS.length).fill(0);
const setsOK = new Array(BALL_ANIM_SETS.length).fill(0);
const setsFail = new Array(BALL_ANIM_SETS.length).fill(0);

function finalizeSetIfDone(setIdx) {
  if (setsOK[setIdx]+setsFail[setIdx]!==BALL_FRAME_COUNT) return;
  const valid = setsFramesCompact[setIdx].filter(img=>img && img.complete && img.naturalWidth>0);
  setsFramesCompact[setIdx] = valid;
  setsEffectiveCount[setIdx] = valid.length;
  console.log(`üéæ Set ${setIdx+1} listo. USANDO=${setsEffectiveCount[setIdx]}`);
}
for (let s=0;s<BALL_ANIM_SETS.length;s++){
  setsFramesCompact[s] = new Array(BALL_FRAME_COUNT);
  for(let i=1;i<=BALL_FRAME_COUNT;i++){
    const img=new Image();
    const num=String(i).padStart(4,"0");
    const src=`${BALL_ANIM_SETS[s]}${num}${BALL_FRAME_EXT}`;
    img.onload=()=>{ setsOK[s]++; finalizeSetIfDone(s); };
    img.onerror=()=>{ setsFail[s]++; console.error("‚ùå No carg√≥ frame:", src); finalizeSetIfDone(s); };
    img.src=src;
    setsFramesCompact[s][i-1]=img;
  }
}

// -------------------- HELPERS --------------------
function getVisualScale(y){ const t=Math.min(1,Math.max(0,y/sceneHeight)); return DEPTH_MIN+(DEPTH_MAX-DEPTH_MIN)*t; }
function wrapToPi(a){ a=(a+Math.PI)%(Math.PI*2); if(a<0)a+=Math.PI*2; return a-Math.PI; }
function lerpAngle(a,b,t){ const d=wrapToPi(b-a); return a+d*t; }

// -------------------- BALLS --------------------
const balls=[];
for(let i=0;i<BALL_COUNT;i++){
  const x=Math.random()*sceneWidth;
  const y=Math.random()*sceneHeight;
  balls.push({x,y,px:x,py:y,vx:0,vy:0,spin:Math.random()*200,heading:0,vScale:getVisualScale(y),setIdx:(Math.random()*BALL_ANIM_SETS.length)|0});
}

// -------------------- DIBUJOS --------------------
function drawShadow(b){
  const vs=b.vScale;
  const sx=b.x+SHADOW_OFFSET_X;
  const sy=b.y+SHADOW_OFFSET_Y;
  sctx.save();
  sctx.globalAlpha=SHADOW_OPACITY;
  sctx.translate(sx,sy);
  sctx.scale(SHADOW_STRETCH_X*vs,SHADOW_STRETCH_Y*vs);
  const r=BALL_RADIUS*1.0;
  const g=sctx.createRadialGradient(0,0,0,0,0,r);
  g.addColorStop(0,"rgba(0,0,0,1)");
  g.addColorStop(0.55,"rgba(0,0,0,0.9)");
  g.addColorStop(1,"rgba(0,0,0,0)");
  sctx.fillStyle=g;
  sctx.beginPath();
  sctx.arc(0,0,r,0,Math.PI*2);
  sctx.fill();
  sctx.restore();
}

function drawBallSprite(b){
  let frames=setsFramesCompact[b.setIdx];
  let count=setsEffectiveCount[b.setIdx];
  if(!count){
    for(let s=0;s<setsEffectiveCount.length;s++){
      if(setsEffectiveCount[s]>0){ frames=setsFramesCompact[s]; count=setsEffectiveCount[s]; break; }
    }
  }
  if(!count){ sctx.fillStyle="#FFD700"; sctx.beginPath(); sctx.arc(b.x,b.y,BALL_RADIUS,0,Math.PI*2); sctx.fill(); return; }
  const speed=Math.sqrt(b.vx*b.vx+b.vy*b.vy);
  if(speed>=SPIN_FREEZE_SPEED){ const targetHeading=Math.atan2(b.vy,b.vx); b.heading=lerpAngle(b.heading,targetHeading,HEADING_SMOOTH); b.spin+=speed*BALL_SPIN_SPEED; }
  const frameIndex=((Math.floor(b.spin)%count)+count)%count;
  const frame=frames[frameIndex];
  const d=BALL_DIAMETER*b.vScale;
  sctx.save(); sctx.translate(b.x,b.y); sctx.rotate(b.heading+ROT_OFFSET); sctx.imageSmoothingEnabled=true; sctx.drawImage(frame,-d/2,-d/2,d,d); sctx.restore();
}

function drawTrackSegment(b){
  const speed=Math.sqrt(b.vx*b.vx+b.vy*b.vy);
  if(speed<TRACKS_SPEED_THRESHOLD) return;
  const dx=b.x-b.px, dy=b.y-b.py;
  const segLen=Math.sqrt(dx*dx+dy*dy);
  if(segLen<TRACKS_MIN_SEGMENT) return;
  sctx.save();
  sctx.globalAlpha=TRACKS_ALPHA;
  sctx.strokeStyle=`rgb(${TRACKS_COLOR})`;
  sctx.beginPath();
  sctx.moveTo(b.px,b.py);
  sctx.lineTo(b.x,b.y);
  sctx.stroke();
  sctx.restore();
}

// -------------------- LOOP --------------------
function step(){
  // limpiar escena total
  sctx.clearRect(0,0,sceneWidth,sceneHeight);
  // fondo
  if(bgImg.complete)sctx.drawImage(bgImg,0,0,sceneWidth,sceneHeight);
  
  // mouse coords c√°mara
  const mx=mouse.x+cameraX; const my=mouse.y+cameraY;
  if(mouseRepulseFramesLeft>0) mouseRepulseFramesLeft--;

  // repulsion
  if(mouseRepulseFramesLeft>0){
    for(const b of balls){
      const dx=b.x-mx; const dy=b.y-my; const dist=Math.sqrt(dx*dx+dy*dy);
      if(dist<REPULSION_RADIUS){
        const angle=Math.atan2(dy,dx);
        const force=(REPULSION_RADIUS-dist)/REPULSION_RADIUS*REPULSION_FORCE;
        b.vx+=Math.cos(angle)*force;
        b.vy+=Math.sin(angle)*force;
      }
    }
  }

  // colisiones
  const RESTITUTION=0.05, DAMPING=0.85, SLOP=1.2, CORRECTION=0.6;
  for(let i=0;i<balls.length;i++){
    for(let j=i+1;j<balls.length;j++){
      const b1=balls[i],b2=balls[j];
      let dx=b2.x-b1.x, dy=b2.y-b1.y, dist=Math.sqrt(dx*dx+dy*dy)||0.0001;
      const minDist=BALL_RADIUS*2.1, penetration=minDist-dist;
      if(penetration>0){
        const nx=dx/dist, ny=dy/dist;
        const penCorrected=Math.max(penetration-SLOP,0);
        const push=(penCorrected/2)*CORRECTION;
        b1.x-=nx*push; b1.y-=ny*push;
        b2.x+=nx*push; b2.y+=ny*push;
        const rvx=b2.vx-b1.vx, rvy=b2.vy-b1.vy;
        const velAlongNormal=rvx*nx+rvy*ny;
        if(velAlongNormal>0) continue;
        const jImpulse=-(1+RESTITUTION)*velAlongNormal/2;
        b1.vx-=jImpulse*nx; b1.vy-=jImpulse*ny;
        b2.vx+=jImpulse*nx; b2.vy+=jImpulse*ny;
        b1.vx*=DAMPING; b1.vy*=DAMPING;
        b2.vx*=DAMPING; b2.vy*=DAMPING;
      }
    }
  }

  // mover pelotas + tracks
  for(const b of balls){
    b.px=b.x; b.py=b.y;
    b.x+=b.vx; b.y+=b.vy;
    b.vScale=getVisualScale(b.y);
    drawTrackSegment(b);
    b.vx*=FRICTION; b.vy*=FRICTION;
    if(Math.abs(b.vx)<SLEEP_VEL) b.vx=0;
    if(Math.abs(b.vy)<SLEEP_VEL) b.vy=0;
    // clamp f√≠sico
    if(b.x<BALL_RADIUS)b.x=BALL_RADIUS;
    if(b.x>sceneWidth-BALL_RADIUS)b.x=sceneWidth-BALL_RADIUS;
    if(b.y<BALL_RADIUS)b.y=BALL_RADIUS;
    if(b.y>sceneHeight-BALL_RADIUS)b.y=sceneHeight-BALL_RADIUS;
  }

  // dibujar sombras + pelotas
  for(const b of balls) drawShadow(b);
  for(const b of balls) drawBallSprite(b);

  // highlight
  if(highlightReady){
    sctx.globalAlpha=HIGHLIGHT_OPACITY;
    for(const b of balls){
      const d=HIGHLIGHT_SIZE*b.vScale;
      sctx.drawImage(highlightImg,b.x-d/2+HIGHLIGHT_OFFSET_X,b.y-d/2+HIGHLIGHT_OFFSET_Y,d,d);
    }

// sombras
  if(shadowOverlayImg.complete)
  sctx.globalAlpha= SHADOWOVERLAYO_PACITY;
  sctx.drawImage(shadowOverlayImg,0,0,sceneWidth,sceneHeight);


    sctx.globalAlpha=1;
  }

  // render c√°mara
  ctx.clearRect(0,0,cameraWidth,cameraHeight);
  ctx.drawImage(sceneCanvas,cameraX,cameraY,cameraWidth,cameraHeight,0,0,cameraWidth,cameraHeight);

  requestAnimationFrame(step);
}
step();
</script>
</body>
</html>

