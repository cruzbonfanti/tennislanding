<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Tennis Ball Layers Test</title>

<style>
  html, body { margin: 0; overflow: hidden; background: #000; }

  #scene {
    position: fixed;
    inset: 0;
    will-change: transform;
    transform: translate3d(0,0,0);
  }

  #bg {
    position: absolute;
    inset: 0;
    background-image: url("./tenniscourt.png");
    background-size: cover;
    background-repeat: no-repeat;
    background-position: 50% 50%;
    z-index: 0;
  }

  #tracks {
    position: absolute;
    inset: 0;
    display: block;
    z-index: 1;
    pointer-events: none;
  }

  #c {
    position: absolute;
    inset: 0;
    display: block;
    z-index: 2;
  }

  #shadowOverlay {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    pointer-events: none;
    z-index: 3;
    opacity: 0.6;
    will-change: transform;
    transform: translate3d(0,0,0);
  }
</style>
</head>

<body>
<div id="scene">
  <div id="bg"></div>
  <canvas id="tracks"></canvas>
  <canvas id="c"></canvas>
  <img id="shadowOverlay" src="./tenniscourt_shadows.png" alt="" />
</div>

<script>
const scene = document.getElementById("scene");
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const tracksCanvas = document.getElementById("tracks");
const tctx = tracksCanvas.getContext("2d");

const shadowOverlay = document.getElementById("shadowOverlay");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  tracksCanvas.width = window.innerWidth;
  tracksCanvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// ---------------- CONFIG ----------------
const BALL_COUNT = 480;
const BALL_SCALE = 1.05;

// ---- BALL SPRITE ANIMATION (3 variantes) ----
const BALL_FRAME_COUNT = 48;
const BALL_FRAME_EXT = ".png";

// ‚úÖ 3 carpetas (cada una con 0001.png .. 0048.png)
const BALL_ANIM_SETS = [
  "./Ball_animation1/",
  "./Ball_animation2/",
  "./Ball_animation3/"
];

const BALL_SPIN_SPEED = 0.22;

// Congela frames + heading cuando va muy lento
const SPIN_FREEZE_SPEED = 0.08;

// HUELLAS
const TRACKS_SPEED_THRESHOLD = 0.10;
const TRACKS_WIDTH = Math.max(6, 12.0 * BALL_SCALE);
const TRACKS_ALPHA = 0.035;
const TRACKS_COLOR = "0,0,0";
const TRACKS_MIN_SEGMENT = Math.max(0.6, 1.2 * BALL_SCALE);

// ORIENTACI√ìN
const ROT_OFFSET = 0;
const HEADING_SMOOTH = 0.15;

// Base (f√≠sica)
const BALL_RADIUS_BASE = 22;
const BALL_RADIUS = BALL_RADIUS_BASE * BALL_SCALE;
const BALL_DIAMETER = BALL_RADIUS * 2;

// ‚úÖ DEPTH SOLO VISUAL (sutil)
const DEPTH_MIN = 0.97; // arriba
const DEPTH_MAX = 1.03; // abajo

// Mouse repulsi√≥n
const REPULSION_RADIUS_BASE = 110;
const REPULSION_FORCE = 5.5;
const REPULSION_RADIUS = REPULSION_RADIUS_BASE * BALL_SCALE;

// threshold movimiento mouse
const MOUSE_MOVE_THRESHOLD_PX = 1;
const MOUSE_REPULSE_COOLDOWN_FRAMES = 70;

const FRICTION = 0.8;
const SLEEP_VEL = 0.1;

// Sombra (pelota)
const SHADOW_OPACITY = 0.7;
const SHADOW_STRETCH_X = 1.5;
const SHADOW_STRETCH_Y = 0.5;
const SHADOW_OFFSET_X = 14 * BALL_SCALE;
const SHADOW_OFFSET_Y = 16 * BALL_SCALE;

// Highlight
const HIGHLIGHT_SRC = "./highlight.png";
const HIGHLIGHT_SIZE = 44 * BALL_SCALE;
const HIGHLIGHT_OFFSET_X = 0;
const HIGHLIGHT_OFFSET_Y = 0;

// Parallax (scene)
const PARALLAX_MAX_PX = 15;
const PARALLAX_SMOOTH = 0.08;

// Parallax diferencial (overlay sombras)
const SHADOW_PARALLAX_MULT = 0.4;
const SHADOW_PARALLAX_SMOOTH = 1;
// --------------------------------------

// canvas huellas
tctx.lineCap = "round";
tctx.lineJoin = "round";
tctx.lineWidth = TRACKS_WIDTH;

// mouse + gating
const mouse = { x: -9999, y: -9999, px: -9999, py: -9999 };
let parallaxX = 0, parallaxY = 0;
let parallaxTargetX = 0, parallaxTargetY = 0;
let shadowPX = 0, shadowPY = 0;
let mouseRepulseFramesLeft = 0;

window.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;

  const nx = (mouse.x / window.innerWidth) * 2 - 1;
  const ny = (mouse.y / window.innerHeight) * 2 - 1;
  parallaxTargetX = -nx * PARALLAX_MAX_PX;
  parallaxTargetY = -ny * PARALLAX_MAX_PX;

  const dx = mouse.x - mouse.px;
  const dy = mouse.y - mouse.py;

  if (mouse.px < -9000) {
    mouse.px = mouse.x;
    mouse.py = mouse.y;
    return;
  }

  const dist = Math.sqrt(dx*dx + dy*dy);
  if (dist >= MOUSE_MOVE_THRESHOLD_PX) {
    mouseRepulseFramesLeft = MOUSE_REPULSE_COOLDOWN_FRAMES;
  }

  mouse.px = mouse.x;
  mouse.py = mouse.y;
});

// ‚úÖ depth helper (solo visual)
function getVisualScale(y) {
  const t = Math.min(1, Math.max(0, y / canvas.height));
  return DEPTH_MIN + (DEPTH_MAX - DEPTH_MIN) * t;
}

// ================== LOAD FRAMES POR SET ==================
/*
  setsFramesCompact[setIndex] = [Image, Image, ...] (solo las que cargaron bien)
  setsEffectiveCount[setIndex] = cantidad usable
*/
const setsFramesCompact = BALL_ANIM_SETS.map(() => []);
const setsEffectiveCount = new Array(BALL_ANIM_SETS.length).fill(0);

// tracking carga
const setsOK = new Array(BALL_ANIM_SETS.length).fill(0);
const setsFail = new Array(BALL_ANIM_SETS.length).fill(0);

function finalizeSetIfDone(setIdx) {
  if (setsOK[setIdx] + setsFail[setIdx] !== BALL_FRAME_COUNT) return;

  // Filtramos v√°lidas manteniendo orden
  const valid = setsFramesCompact[setIdx].filter(img => img && img.complete && img.naturalWidth > 0);
  setsFramesCompact[setIdx] = valid;
  setsEffectiveCount[setIdx] = valid.length;

  console.log(
    `üéæ Set ${setIdx+1} listo. OK=${setsOK[setIdx]} FAIL=${setsFail[setIdx]} -> USANDO=${setsEffectiveCount[setIdx]}`
  );

  if (setsEffectiveCount[setIdx] === 0) {
    console.warn(`‚ö†Ô∏è Set ${setIdx+1} no tiene frames v√°lidos. Revis√° rutas/archivos.`);
  }
}

// Cargamos todos los sets
for (let s = 0; s < BALL_ANIM_SETS.length; s++) {
  // pre-alloc con null para preservar √≠ndices, despu√©s filtramos en finalize
  setsFramesCompact[s] = new Array(BALL_FRAME_COUNT);

  for (let i = 1; i <= BALL_FRAME_COUNT; i++) {
    const img = new Image();
    const num = String(i).padStart(4, "0"); // 0001..0048
    const src = `${BALL_ANIM_SETS[s]}${num}${BALL_FRAME_EXT}`;

    img.onload = () => { setsOK[s]++; finalizeSetIfDone(s); };
    img.onerror = () => { setsFail[s]++; console.error("‚ùå No carg√≥ frame:", src); finalizeSetIfDone(s); };

    img.src = src;
    setsFramesCompact[s][i - 1] = img;
  }
}

// Highlight image
const highlightImg = new Image();
highlightImg.src = HIGHLIGHT_SRC;
let highlightReady = false;
highlightImg.onload = () => highlightReady = true;
highlightImg.onerror = () => console.error("‚ùå No carg√≥ highlight:", HIGHLIGHT_SRC);

// ---- ANGLE HELPERS ----
function wrapToPi(a) {
  a = (a + Math.PI) % (Math.PI * 2);
  if (a < 0) a += Math.PI * 2;
  return a - Math.PI;
}
function lerpAngle(a, b, t) {
  const d = wrapToPi(b - a);
  return a + d * t;
}

// pelotas
const balls = [];
for (let i = 0; i < BALL_COUNT; i++) {
  const x = Math.random() * canvas.width;
  const y = Math.random() * canvas.height;

  balls.push({
    x, y,
    px: x, py: y,
    vx: 0, vy: 0,
    spin: Math.random() * 200,
    heading: 0,
    vScale: getVisualScale(y),

    // ‚úÖ asignaci√≥n aleatoria de set (0..2) UNA SOLA VEZ
    setIdx: (Math.random() * BALL_ANIM_SETS.length) | 0
  });
}

// ---------------- SOMBRA ----------------
function drawShadow(b) {
  const vs = b.vScale;
  const sx = b.x + SHADOW_OFFSET_X;
  const sy = b.y + SHADOW_OFFSET_Y;

  ctx.save();
  ctx.globalAlpha = SHADOW_OPACITY;
  ctx.translate(sx, sy);

  // escala visual aplicada a la sombra
  ctx.scale(SHADOW_STRETCH_X * vs, SHADOW_STRETCH_Y * vs);

  const r = BALL_RADIUS * 1.0;
  const g = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
  g.addColorStop(0.0, "rgba(0,0,0,1)");
  g.addColorStop(0.55, "rgba(0,0,0,0.9)");
  g.addColorStop(1.0, "rgba(0,0,0,0)");

  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// ---------------- PELOTA SPRITE (por set) ----------------
function drawBallSprite(b) {
  const set = b.setIdx;

  // si el set asignado no tiene frames todav√≠a, buscamos un fallback r√°pido
  let frames = setsFramesCompact[set];
  let count = setsEffectiveCount[set];

  if (!count) {
    // fallback: primer set que tenga frames v√°lidos
    for (let s = 0; s < setsEffectiveCount.length; s++) {
      if (setsEffectiveCount[s] > 0) {
        frames = setsFramesCompact[s];
        count = setsEffectiveCount[s];
        break;
      }
    }
  }

  if (!count) {
    // fallback final: c√≠rculo amarillo si no carg√≥ nada todav√≠a
    ctx.fillStyle = "#FFD700";
    ctx.beginPath();
    ctx.arc(b.x, b.y, BALL_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    return;
  }

  const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);

  if (speed >= SPIN_FREEZE_SPEED) {
    const targetHeading = Math.atan2(b.vy, b.vx);
    b.heading = lerpAngle(b.heading, targetHeading, HEADING_SMOOTH);
    b.spin += speed * BALL_SPIN_SPEED;
  }

  const frameIndex = ((Math.floor(b.spin) % count) + count) % count;
  const frame = frames[frameIndex];

  const d = BALL_DIAMETER * b.vScale;

  ctx.save();
  ctx.translate(b.x, b.y);
  ctx.rotate(b.heading + ROT_OFFSET);
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(frame, -d/2, -d/2, d, d);
  ctx.restore();
}

// HUELLAS
function drawTrackSegment(b) {
  const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
  if (speed < TRACKS_SPEED_THRESHOLD) return;

  const dx = b.x - b.px;
  const dy = b.y - b.py;
  const segLen = Math.sqrt(dx*dx + dy*dy);
  if (segLen < TRACKS_MIN_SEGMENT) return;

  tctx.save();
  tctx.globalAlpha = TRACKS_ALPHA;
  tctx.strokeStyle = `rgb(${TRACKS_COLOR})`;
  tctx.beginPath();
  tctx.moveTo(b.px, b.py);
  tctx.lineTo(b.x, b.y);
  tctx.stroke();
  tctx.restore();
}

// ---------------- LOOP ----------------
function step() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // PARALLAX (scene)
  parallaxX += (parallaxTargetX - parallaxX) * PARALLAX_SMOOTH;
  parallaxY += (parallaxTargetY - parallaxY) * PARALLAX_SMOOTH;
  scene.style.transform = `translate3d(${parallaxX}px, ${parallaxY}px, 0)`;

  // parallax diferencial overlay sombras
  const targetSX = -parallaxX * SHADOW_PARALLAX_MULT;
  const targetSY = -parallaxY * SHADOW_PARALLAX_MULT;
  shadowPX += (targetSX - shadowPX) * SHADOW_PARALLAX_SMOOTH;
  shadowPY += (targetSY - shadowPY) * SHADOW_PARALLAX_SMOOTH;
  shadowOverlay.style.transform = `translate3d(${shadowPX.toFixed(2)}px, ${shadowPY.toFixed(2)}px, 0)`;

  // mouse en coords escena
  const mx = mouse.x - parallaxX;
  const my = mouse.y - parallaxY;

  if (mouseRepulseFramesLeft > 0) mouseRepulseFramesLeft--;

  // 1) REPULSI√ìN MOUSE
  if (mouseRepulseFramesLeft > 0) {
    for (const b of balls) {
      const dx = b.x - mx;
      const dy = b.y - my;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < REPULSION_RADIUS) {
        const angle = Math.atan2(dy, dx);
        const force = (REPULSION_RADIUS - dist) / REPULSION_RADIUS * REPULSION_FORCE;
        b.vx += Math.cos(angle) * force;
        b.vy += Math.sin(angle) * force;
      }
    }
  }

  // 2) COLISIONES (radio fijo)
  const RESTITUTION = 0.05;
  const DAMPING = 0.85;
  const SLOP = 1.2;
  const CORRECTION = 0.6;

  for (let i = 0; i < balls.length; i++) {
    for (let j = i + 1; j < balls.length; j++) {
      const b1 = balls[i];
      const b2 = balls[j];

      let dx = b2.x - b1.x;
      let dy = b2.y - b1.y;
      let dist = Math.sqrt(dx*dx + dy*dy) || 0.0001;

      const minDist = BALL_RADIUS * 2.1; // fijo
      const penetration = minDist - dist;

      if (penetration > 0) {
        const nx = dx / dist;
        const ny = dy / dist;

        const penCorrected = Math.max(penetration - SLOP, 0);
        const push = (penCorrected / 2) * CORRECTION;

        b1.x -= nx * push; b1.y -= ny * push;
        b2.x += nx * push; b2.y += ny * push;

        const rvx = b2.vx - b1.vx;
        const rvy = b2.vy - b1.vy;
        const velAlongNormal = rvx * nx + rvy * ny;
        if (velAlongNormal > 0) continue;

        const jImpulse = -(1 + RESTITUTION) * velAlongNormal / 2;
        const impulseX = jImpulse * nx;
        const impulseY = jImpulse * ny;

        b1.vx -= impulseX; b1.vy -= impulseY;
        b2.vx += impulseX; b2.vy += impulseY;

        b1.vx *= DAMPING; b1.vy *= DAMPING;
        b2.vx *= DAMPING; b2.vy *= DAMPING;
      }
    }
  }

  // 3) MOVER (+ huellas) + depth visual por Y
  for (const b of balls) {
    b.px = b.x;
    b.py = b.y;

    b.x += b.vx;
    b.y += b.vy;

    b.vScale = getVisualScale(b.y);

    drawTrackSegment(b);

    b.vx *= FRICTION;
    b.vy *= FRICTION;

    if (Math.abs(b.vx) < SLEEP_VEL) b.vx = 0;
    if (Math.abs(b.vy) < SLEEP_VEL) b.vy = 0;

    // clamp f√≠sico (radio fijo)
    if (b.x < BALL_RADIUS) b.x = BALL_RADIUS;
    if (b.x > canvas.width - BALL_RADIUS) b.x = canvas.width - BALL_RADIUS;
    if (b.y < BALL_RADIUS) b.y = BALL_RADIUS;
    if (b.y > canvas.height - BALL_RADIUS) b.y = canvas.height - BALL_RADIUS;
  }

  // -------- RENDER --------
  for (const b of balls) drawShadow(b);
  for (const b of balls) drawBallSprite(b);

  if (highlightReady) {
    ctx.globalAlpha = 0.9;
    for (const b of balls) {
      const d = HIGHLIGHT_SIZE * b.vScale;
      ctx.drawImage(
        highlightImg,
        b.x - d / 2 + HIGHLIGHT_OFFSET_X,
        b.y - d / 2 + HIGHLIGHT_OFFSET_Y,
        d,
        d
      );
    }
    ctx.globalAlpha = 1;
  }

  requestAnimationFrame(step);
}

step();
</script>
</body>
</html>
